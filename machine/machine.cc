// machine.cc 
//	Routines for simulating the execution of user programs.
//
//  DO NOT CHANGE -- part of the machine emulation
//
// Copyright (c) 1992-1993 The Regents of the University of California.
// All rights reserved.  See copyright.h for copyright notice and limitation 
// of liability and disclaimer of warranty provisions.

#include "copyright.h"
#include "machine.h"
#include "system.h"

// Textual names of the exceptions that can be generated by user program
// execution, for debugging.
static char* exceptionNames[] = { "no exception", "syscall", 
				"page fault/no TLB entry", "page read only",
				"bus error", "address error", "overflow",
				"illegal instruction" };

//----------------------------------------------------------------------
// CheckEndian
// 	Check to be sure that the host really uses the format it says it 
//	does, for storing the bytes of an integer.  Stop on error.
//----------------------------------------------------------------------

static
void CheckEndian()
{
    union checkit {
        char charword[4];
        unsigned int intword;
    } check;

    check.charword[0] = 1;
    check.charword[1] = 2;
    check.charword[2] = 3;
    check.charword[3] = 4;

#ifdef HOST_IS_BIG_ENDIAN
    ASSERT (check.intword == 0x01020304);
#else
    ASSERT (check.intword == 0x04030201);
#endif
}

//----------------------------------------------------------------------
// Machine::Machine
// 	Initialize the simulation of user program execution.
//
//	"debug" -- if TRUE, drop into the debugger after each user instruction
//		is executed.
//----------------------------------------------------------------------

Machine::Machine(bool debug, TLBSwapPolicy tlbPolicy)
{
    int i;
    tlbSwapPolicy = tlbPolicy;
    nextFramePoint = 0;

    for (i = 0; i < NumTotalRegs; i++)
        registers[i] = 0;
    mainMemory = new char[MemorySize];
    for (i = 0; i < MemorySize; i++)
      	mainMemory[i] = 0;
#ifdef USE_TLB
    tlb = new TranslationEntry[TLBSize];
    for (i = 0; i < TLBSize; i++)
	tlb[i].valid = FALSE;
    tlb[i].lastUseTime = 0;
    tlb[i].firstUseTime = 0;
    tlb[i].clockUse = 0;
    tlb[i].use = FALSE;
    tlb[i].dirty = FALSE;
    pageTable = NULL;
#else	// use linear page table
    tlb = NULL;
    pageTable = NULL;
#endif

    singleStep = debug;
    CheckEndian();
}

//----------------------------------------------------------------------
// Machine::~Machine
// 	De-allocate the data structures used to simulate user program execution.
//----------------------------------------------------------------------

Machine::~Machine()
{
    delete [] mainMemory;
    if (tlb != NULL)
        delete [] tlb;
}

//----------------------------------------------------------------------
// Machine::RaiseException
// 	Transfer control to the Nachos kernel from user mode, because
//	the user program either invoked a system call, or some exception
//	occured (such as the address translation failed).
//
//	"which" -- the cause of the kernel trap
//	"badVaddr" -- the virtual address causing the trap, if appropriate
//----------------------------------------------------------------------

void
Machine::RaiseException(ExceptionType which, int badVAddr)
{
    DEBUG('m', "Exception: %s\n", exceptionNames[which]);
    
//  ASSERT(interrupt->getStatus() == UserMode);
    registers[BadVAddrReg] = badVAddr;
    DelayedLoad(0, 0);			// finish anything in progress
    interrupt->setStatus(SystemMode);
    ExceptionHandler(which);		// interrupts are enabled at this point
    interrupt->setStatus(UserMode);
}

//----------------------------------------------------------------------
// Machine::Debugger
// 	Primitive debugger for user programs.  Note that we can't use
//	gdb to debug user programs, since gdb doesn't run on top of Nachos.
//	It could, but you'd have to implement *a lot* more system calls
//	to get it to work!
//
//	So just allow single-stepping, and printing the contents of memory.
//----------------------------------------------------------------------

void Machine::Debugger()
{
    char *buf = new char[80];
    int num;

    interrupt->DumpState();
    DumpState();
    printf("%d> ", stats->totalTicks);
    fflush(stdout);
    fgets(buf, 80, stdin);
    if (sscanf(buf, "%d", &num) == 1)
	runUntilTime = num;
    else {
	runUntilTime = 0;
	switch (*buf) {
	  case '\n':
	    break;
	    
	  case 'c':
	    singleStep = FALSE;
	    break;
	    
	  case '?':
	    printf("Machine commands:\n");
	    printf("    <return>  execute one instruction\n");
	    printf("    <number>  run until the given timer tick\n");
	    printf("    c         run until completion\n");
	    printf("    ?         print help message\n");
	    break;
	}
    }
    delete [] buf;
}
 
//----------------------------------------------------------------------
// Machine::DumpState
// 	Print the user program's CPU state.  We might print the contents
//	of memory, but that seemed like overkill.
//----------------------------------------------------------------------

void
Machine::DumpState()
{
    int i;
    
    printf("Machine registers:\n");
    for (i = 0; i < NumGPRegs; i++)
	switch (i) {
	  case StackReg:
	    printf("\tSP(%d):\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	    
	  case RetAddrReg:
	    printf("\tRA(%d):\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	  
	  default:
	    printf("\t%d:\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	}
    
    printf("\tHi:\t0x%x", registers[HiReg]);
    printf("\tLo:\t0x%x\n", registers[LoReg]);
    printf("\tPC:\t0x%x", registers[PCReg]);
    printf("\tNextPC:\t0x%x", registers[NextPCReg]);
    printf("\tPrevPC:\t0x%x\n", registers[PrevPCReg]);
    printf("\tLoad:\t0x%x", registers[LoadReg]);
    printf("\tLoadV:\t0x%x\n", registers[LoadValueReg]);
    printf("\n");
}

//----------------------------------------------------------------------
// Machine::ReadRegister/WriteRegister
//   	Fetch or write the contents of a user program register.
//----------------------------------------------------------------------

int Machine::ReadRegister(int num)
    {
	ASSERT((num >= 0) && (num < NumTotalRegs));
	return registers[num];
    }

void Machine::WriteRegister(int num, int value)
    {
	ASSERT((num >= 0) && (num < NumTotalRegs));
	// DEBUG('m', "WriteRegister %d, value %d\n", num, value);
	registers[num] = value;
    }

void
Machine::PCForward()
{
	WriteRegister(PrevPCReg, registers[PCReg]);
	WriteRegister(PCReg, registers[PCReg] + sizeof(int));
	WriteRegister(NextPCReg, registers[NextPCReg] + sizeof(int));
}


void
Machine::InvalidTLB()
{
	if(tlb == NULL)
		return;
	int i;
	TranslationEntry* e = NULL;
	for(i = 0; i<TLBSize; i++)
	{
		if(tlb[i].valid) {
			e = &tlb[i];
			pageTable[e->virtualPage] = *e;
			tlb[i].valid = FALSE;
		}
	}
}


void
Machine::UpdateTLB(int idx)
{
	if(idx < 0 || idx > TLBSize)
	{
		printf("UpdateTLB: idx err\n");
		return;
	}
	switch(tlbSwapPolicy)
	{
	case LRU:
		tlb[idx].lastUseTime = stats->totalTicks;
		break;
	case CLOCK:
		tlb[idx].clockUse = 1;
		break;
	case NRU:
	case FIFO_TLB:
		// do nothing
		break;
	}
}

// handle TLB pageFault, swap page from pageTable
int
Machine::TLBSwap(int addr)
{
	// in memory then swap TLB
	switch(tlbSwapPolicy)
	{
	case LRU:
		return LRUSwap(addr);break;
	case FIFO_TLB:
		return FIFOSwap(addr);break;
	case NRU:
		return NRUSwap(addr);break;
	case CLOCK:
		return ClockSwap(addr);break;
	}
	return -1;
}

int
Machine::LRUSwap(int addr)
{
	DEBUG('p',"TLB MISS,use LRU swap\n");
	int idx = 0;
	int vpn = addr/PageSize;
	int offset = addr/PageSize;
	TranslationEntry *entry = &tlb[0];
	int min = tlb[0].lastUseTime;
	bool emptyTLB = false;

	for(int i = 0; i<TLBSize; i++)
	{
		if(!tlb[i].valid)
		{
			emptyTLB = true;
			idx = i;
			entry = &tlb[i];
			break;
		}
		if(tlb[i].lastUseTime < min)
		{
			idx = i;
			entry = &tlb[i];
		}
	}

	tlb[idx].valid = TRUE;
	// test
	//printf("B: TLB[%d] v:%d vpn:%d ppn:%d u:%d d:%d LRU:%d \n",
	//		idx, tlb[idx].valid, tlb[idx].virtualPage, tlb[idx].physicalPage, tlb[idx].use, tlb[idx].dirty, tlb[idx].lastUseTime);
	// update TLB
	if(!emptyTLB)
		pageTable[entry->virtualPage] = *entry;
	*entry = pageTable[vpn];
	entry->lastUseTime = stats->totalTicks;
	//printf("A: TLB[%d] v:%d vpn:%d ppn:%d u:%d d:%d LRU:%d\n",
	//			idx, tlb[idx].valid, tlb[idx].virtualPage, tlb[idx].physicalPage, tlb[idx].use, tlb[idx].dirty, tlb[idx].lastUseTime);

	return idx;
}


int
Machine::FIFOSwap(int addr)
{
	DEBUG('p',"TLB MISS,use FIFO swap\n");
	int idx = 0;
	int vpn = addr/PageSize;
	int offset = addr/PageSize;
	TranslationEntry *entry = &tlb[0];
	int min = tlb[0].firstUseTime;
	bool emptyTLB = false;

	for(int i = 0; i<TLBSize; i++)
	{
		if(!tlb[i].valid)
		{
			emptyTLB = true;
			idx = i;
			entry = &tlb[i];
			break;
		}
		if(tlb[i].firstUseTime < min)
		{
			idx = i;
			entry = &tlb[i];
		}
	}

	// test
	printf("B: TLB[%d] v:%d vpn:%d ppn:%d u:%d d:%d firstUseTime:%d \n",
		idx, tlb[idx].valid, tlb[idx].virtualPage, tlb[idx].physicalPage, tlb[idx].use, tlb[idx].dirty, tlb[idx].firstUseTime);
	// update TLB
	if(!emptyTLB)
		pageTable[entry->virtualPage] = *entry;
	*entry = pageTable[vpn];
	entry->firstUseTime = stats->totalTicks;
	printf("A: TLB[%d] v:%d vpn:%d ppn:%d u:%d d:%d firstUseTime:%d\n",
					idx, tlb[idx].valid, tlb[idx].virtualPage, tlb[idx].physicalPage, tlb[idx].use, tlb[idx].dirty, tlb[idx].firstUseTime);

	return idx;
}


int
Machine::ClockSwap(int addr)
{
	DEBUG('p',"TLB MISS,use Clock swap\n");
	int idx = -1;
	int vpn = addr/PageSize;
	int offset = addr/PageSize;
	TranslationEntry *entry = NULL;
	bool emptyTLB = false;
	bool found = false;
	do {
		if(tlb[nextFramePoint].clockUse == 0)
		{
			if(!tlb[nextFramePoint].valid)
				emptyTLB = true;
			idx = nextFramePoint;
			entry = &tlb[nextFramePoint];
			found = true;
			printf("TLB[%d] clock expired \n", idx);
		} else {
			--tlb[nextFramePoint].clockUse;
			printf("TLB[%d] clock second chance \n", nextFramePoint);
		}
		nextFramePoint = (nextFramePoint + 1)%TLBSize;
	} while(!found);

	// test
	printf("B: TLB[%d] v:%d vpn:%d ppn:%d u:%d d:%d clockUse:%d \n",
		idx, tlb[idx].valid, tlb[idx].virtualPage, tlb[idx].physicalPage, tlb[idx].use, tlb[idx].dirty, tlb[idx].clockUse);
	// update TLB
	if(!emptyTLB)
		pageTable[entry->virtualPage] = *entry;
	*entry = pageTable[vpn];
	entry->clockUse = 1;
	printf("A: TLB[%d] v:%d vpn:%d ppn:%d u:%d d:%d clockUse:%d\n",
						idx, tlb[idx].valid, tlb[idx].virtualPage, tlb[idx].physicalPage, tlb[idx].use, tlb[idx].dirty, tlb[idx].clockUse);

	return idx;
}

// NRU CLOCK
int
Machine::NRUSwap(int addr)
{
	DEBUG('p',"TLB MISS,use NRU swap\n");
	int idx = -1;
	int vpn = addr/PageSize;
	int offset = addr/PageSize;
	TranslationEntry *entry = NULL;
	bool emptyTLB = false;
	bool found = false;
	int roundCount = 0;
	do {
		if ((roundCount/TLBSize)%2 == 0) {
			if(tlb[nextFramePoint].use == 0 && tlb[nextFramePoint].dirty == 0)
			{
				if(!tlb[nextFramePoint].valid)
					emptyTLB = true;
				idx = nextFramePoint;
				entry = &tlb[nextFramePoint];
				found = true;
				printf("TLB[%d] found u:0 d:0 roundCount:%d \n", idx, roundCount);
			}
		} else if((roundCount/TLBSize)%2 == 1) {
			if(tlb[nextFramePoint].use == 0 && tlb[nextFramePoint].dirty == 1)
			{
				idx = nextFramePoint;
				entry = &tlb[nextFramePoint];
				found = true;
				printf("TLB[%d] found u:0 d:1 roundCount:%d \n", idx, roundCount);
			} else {
				tlb[nextFramePoint].use = 0;
				printf("TLB[%d] reset u:0 d:%d roundCount:%d \n", nextFramePoint, tlb[nextFramePoint].dirty, roundCount);
			}
		}
		++roundCount;
		nextFramePoint = (nextFramePoint + 1)%TLBSize;
	} while(!found);

	// test
	printf("B: TLB[%d] v:%d vpn:%d ppn:%d u:%d d:%d \n",
		idx, tlb[idx].valid, tlb[idx].virtualPage, tlb[idx].physicalPage, tlb[idx].use, tlb[idx].dirty);
	// update TLB
	if(!emptyTLB)
		pageTable[entry->virtualPage] = *entry;
	*entry = pageTable[vpn];
	entry->clockUse = 1;
	printf("A: TLB[%d] v:%d vpn:%d ppn:%d u:%d d:%d \n",
		idx, tlb[idx].valid, tlb[idx].virtualPage, tlb[idx].physicalPage, tlb[idx].use, tlb[idx].dirty);


	return idx;
}


#ifdef USER_PROGRAM
#ifdef VM
/*
 * Function:	called when handling PageFault, swap page into memory
 * 				0. check if the page is in memory, then no need to swap, return 0
 * 				1. find a physical page to be swapped into "disk"(swap file)
 * 				2. swap physical page to "disk", and update the pageTable related to phyPageNum
 * 				3. if need, update TLB
 * 				4. find a physical page to be swapped into memory
 * 				5. check swappingPage:
 * 					1) if -1: lazy load from disk to memory
 * 					2) else : swap physical page from "disk"(swap file) to memory
 * 				6. set pageTable param(physicalPage and valid)
 * */
int
Machine::SwapPage(int addr)
{
	// 0. check if page is in memory(valid)
	// in memory, return 0
	int vpn = addr/PageSize;
	if (pageTable[vpn].valid) {
	    DEBUG('a', "swap page %d: in mem!\n", vpn);
	   	return 0;
 	}

	printf("SwapPage: not in memory start swapping from 'disk'\n");
	// not in memory, need swapping from "disk"(swap file)
	// 1. find a physical page to be swapped into "disk"(swap file)
	int phyPageNum = 0;
	int virPageNum = 0;
	int tid = 0;
	int swappingPage = -1;
	phyPageNum = LRUSwapPage();

	// 2. swap physical page to "disk"
	// update the pageTable related to phyPageNum
	// get phyPageNum --- thread --- addr space --- pageTable --- vpn --- swappingPage
	virPageNum = memManager->GetVirPageNum(phyPageNum);
	tid = memManager->GetThreadId(phyPageNum);
	if(virPageNum < 0 || tid < 0 || tid_pointer[tid]->space == NULL)
		return -1;
	swappingPage = swapManager->swapIntoDisk(phyPageNum);
	tid_pointer[tid]->setPTESwappingPage(virPageNum, swappingPage);// set swappingPage and set valid to false
	//tid_pointer[tid]->space->pageTable[virPageNum].swappingPage =
	//	swapManager->swapIntoDisk(phyPageNum);
	//tid_pointer[tid]->space->pageTable[virPageNum].valid = false;
	printf("SwapPage: page to swap into 'disk': tid:%d vpn:%d ppn:%d swappage:%d\n", tid, virPageNum, phyPageNum, swappingPage);

	// 3. if need, update TLB
	for(int i = 0; i<TLBSize; i++)
	{
		if(tlb[i].physicalPage == phyPageNum) {
			tlb[i].valid = FALSE;
			break;
		}
	}

	// 4. find physical page to be swapped into memory
	swappingPage = pageTable[vpn].swappingPage;
	if(swappingPage == -1)
	{
		// 5. lazy load from disk to memory
		LazyLoad(phyPageNum, vpn);
		printf("SwapPage: lazy load from disk to memory\n");
	} else {
		// 5. swap physical page from "disk"(swap file) to memory
		swapManager->swapOutFromDisk(phyPageNum, swappingPage);
		printf("SwapPage: swap physical page from 'disk''(swap file) to memory\n");
	}

	// 6. set pageTable param
	pageTable[vpn].physicalPage = phyPageNum;
	pageTable[vpn].valid = TRUE;

	return 0;
}

/* Function: 	 find a physical page in memory to swap into disk,
 * virtualPageNum:	virtualPageNum
 * return:		 physical page number
 *
 * */
int
Machine::LRUSwapPage()
{
	// update pageTable by tlb
	int vpn = 0;
	int phyNum = 0;
	int lastUsedTime = 0;
	for(int i = 0; i<TLBSize; i++) {
		if(tlb[i].valid) {
			vpn = tlb[i].virtualPage;
			pageTable[vpn] = tlb[i];
		}
	}
	// update phyMemPageTable by pageTable
	for(int i = 0; i<pageTableSize; i++) {
		if(pageTable[i].valid) {
			phyNum = pageTable[i].physicalPage;
			lastUsedTime = pageTable[i].lastUseTime;
			memManager->UpdateLastUsedTime(phyNum, lastUsedTime);
		}
	}
	return memManager->FindSwapPage();
}
#endif

/*
 * Function: 	load page from file on disk
 * phyPageNum:	phyPageNum in main memory to store new page
 * vpn:			virtual page number
 * */
int
Machine::LazyLoad(int phyPageNum, int vpn)
{
	return currentThread->LazyLoad(phyPageNum, vpn);
}
#endif
